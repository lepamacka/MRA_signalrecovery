import time
import numpy as np
from scipy.fft import fft
import circulant
# import matplotlib.pyplot as plt

# Generates shifted and noisy samples, returns total cumulative stats. 
# Should be written with torch or jax instead for efficiency.
def mra_batch_gen(signal, batch, batchnum, sigma_true, rand_shifts=True):

    n = len(signal)

    fft_tot = np.zeros(n, dtype=np.complex128)
    pwrspec_tot = np.zeros(n)
    bispec_tot = np.zeros(shape=(n, n), dtype=np.complex128)
    revmul_tot = np.zeros(n, dtype=np.complex128)
    outer_tot = np.zeros(shape=(n, n), dtype=np.complex128)
    
    signal_cir = circulant.circulant(signal)

    for i in range(batchnum):
        
        if rand_shifts:
            shifts = np.random.randint(n, size=batch)
        else:
            shifts = 0
            
        if np.any(np.iscomplex(signal)):
            data = np.sqrt(1 / 2) * np.random.normal(0, sigma_true, size=(batch, n)) + signal_cir[shifts, :]
            data += np.sqrt(1 / 2) * 1j * np.random.normal(0, sigma_true, size=(batch, n))
        else: 
            data = np.random.normal(0, sigma_true, size=(batch, n)) + signal_cir[shifts, :]
            
        data_fft = fft(data, axis=1)
        fft_tot += np.sum(data_fft, axis=0)
        pwrspec_tot += np.sum(np.square(np.abs(data_fft)), axis=0)
        revmul_tot += np.sum(data_fft * np.roll(np.flip(data_fft, axis=1), 1, axis=1), axis=0)
        
        outer = data_fft.reshape(batch, n, 1) @ np.conj(data_fft.reshape(batch, 1, n))
        outer_tot += np.sum(outer, axis=0)
        
        for k in range(n):
            outer[:, k, :] *= np.roll(data_fft, k, axis=1)
            
        bispec_tot += np.sum(outer, axis=0)

    return fft_tot, pwrspec_tot, bispec_tot, outer_tot, revmul_tot

# Employs total stats generated by mra_batch_gen to estimate signal stats.
def mra_est(dim, num_samples, fft_tot, pwrspec_tot, bispec_tot, outer_tot, revmul_tot, cmplx=False):
    
    sum_est = fft_tot[0] / num_samples
    sqr_est = pwrspec_tot[0] / num_samples
    
    sigma_est = np.sqrt((sqr_est - np.square(np.abs(sum_est))) / dim)
    mean_est = sum_est / dim
    pwrspec_est = pwrspec_tot / num_samples - (sigma_est ** 2) * dim
    pwrspec_est[pwrspec_est < 0] = 0
    
    bispec_adj_est = bispec_tot / num_samples
    bispec_adj_est -= outer_tot * (np.eye(dim) * sum_est) / num_samples
    bispec_adj_est[0, 0] += 2 * np.square(np.abs(sum_est)) * sum_est
    bispec_adj_est[0, :] -= sum_est * pwrspec_tot / num_samples
    bispec_adj_est[:, 0] -= np.conj(sum_est) * revmul_tot / num_samples
    
    noise_bispec_mat = np.diag(np.ones(dim))
    noise_bispec_mat[0, :] += np.ones(dim)
    if not cmplx:
        noise_bispec_mat[:, 0] += np.ones(dim)
    bispec_est = bispec_tot / num_samples - (sigma_est ** 2) * (dim ** 2) * mean_est * noise_bispec_mat
    
    return sigma_est, mean_est, pwrspec_est, bispec_est, bispec_adj_est


if __name__ == '__main__':

    t_start = time.perf_counter()
    
    np.random.seed()
    
    N = 10
    N = N * 2 + 1
    batch_size = 10 ** 3
    batch_number = 10 ** 3
    M = batch_size * batch_number
    sigma = 1
    # prior_str = 10 ** 4
    # prior_prec = 10 ** 1
    # prior_df = 3
    signal_true = np.zeros(N, dtype=np.complex128)
    # signal_true[0:(N-1)//2] = 1.
    # signal_true[0:(N-1)//2] = np.linspace(0, 1, num=(N-1)//2)
    signal_true[0:(N-1)//2] = np.sin(np.arange((N-1)//2)*6*np.pi/N)
    # signal_true[0:(N-1)//2] = 1 + np.linspace(0, 4, num=(N-1)//2) * 1j


    signal_mean = np.mean(signal_true)
    signal_fft = fft(signal_true)
    signal_pwrspec = signal_fft * np.conj(signal_fft)
    signal_bispec = np.outer(signal_fft, np.conj(signal_fft)) * circulant.circulant(signal_fft)
    
    # bispec_adj = signal_bispec
    # bispec_adj -= np.outer(signal_fft, np.conj(signal_fft)) * (np.eye(N) * signal_fft[0])
    # bispec_adj[0, 0] += 2 * np.square(np.abs(signal_fft[0])) * signal_fft[0]
    # bispec_adj[0, :] -= signal_fft[0] * signal_pwrspec
    # bispec_adj[:, 0] -= np.conj(signal_fft[0]) * (signal_fft * circulant.circulant(signal_fft)[:, 0])
    
    signal_adj_fft = fft(signal_true - signal_mean)
    signal_adj_bispec = np.outer(signal_adj_fft, np.conj(signal_adj_fft)) * circulant.circulant(signal_adj_fft)
    

    # prior = signal_true + np.random.normal(0, sigma/prior_prec, N)
    # prior = signal_true + sigma * np.random.standard_t(prior_df) / (np.sqrt(prior_df / (prior_df - 2)) * prior_prec)
    # prior_mean = np.mean(prior)
    # prior_fft = fft(prior)
    # prior_pwrspec = prior_fft * np.conj(prior_fft)
    # prior_bispec = np.outer(prior_fft, np.conj(prior_fft)) * circulant.circulant(prior_fft)

    fft_t, pwrspec_t, bispec_t, outer_t, revmul_t = mra_batch_gen(signal_true, batch_size, batch_number, sigma)
    sigma_e, mean_e, pwrspec_e, bispec_e, bispec_adj_e = mra_est(N, M, fft_t, pwrspec_t, bispec_t, outer_t, revmul_t, np.any(np.iscomplex(signal_true)))
    
    # fac_data = M / (M + prior_str)
    # fac_prior = prior_str / (M + prior_str)
    # mean_e = mean_e * fac_data + prior_mean * fac_prior
    # pwrspec_e = pwrspec_e * fac_data + prior_pwrspec * fac_prior
    # bispec_e = bispec_e * fac_data + prior_bispec * fac_prior
    
    t_stop = time.perf_counter()

    print('Sigma relerr = ' + str(np.linalg.norm((sigma - sigma_e)/sigma)))
    print('Mean relerr = ' + str(np.linalg.norm((signal_mean - mean_e)/signal_mean)))
    print('Powerspec relerr = ' + str(np.linalg.norm(signal_pwrspec - pwrspec_e)/np.linalg.norm(signal_pwrspec)))
    print('Bispec relerr = ' + str(np.linalg.norm(signal_bispec - bispec_e)/np.linalg.norm(signal_bispec)))
    print('Bispec adj relerr = ' + str(np.linalg.norm(signal_adj_bispec - bispec_adj_e)/np.linalg.norm(signal_adj_bispec)))
    print('Time, secs: ' + str(t_stop - t_start))
    # print('Process time, secs: ' + str(t_fract))
